#+TITLE: GNU Emacs Configuration
#+AUTHOR: N. G. Scheurich
#+EMAIL: nick@scheurich.haus

* Introduction

This is my primary *GNU Emacs* configuration file. I say /primary/ because two other files, =early-init.el= and =init.el=, round out the whole of the configuration, though their purposes are tightly constrained and explained in more detail in each file.

This file is an [[https://orgmode.org/][Org Mode]] document written in a [[https://en.wikipedia.org/wiki/Literate_programming][literate programming]] style, with text meant for computer interpretation, i.e. /code/, intermingled with plain-language text meant to be parsed by humans. I find that this paradigm lends works nicely here, as it allows me to colocate my thoughts about parts of the setup along with the Emacs Lisp (Elisp) configuration code itself.

From a technical perspective, when Emacs is started each code block in this document is /tangled/ (exported using to a file using =org-babel-tangle=) and then loaded using =load-file=. Note that /loading/ a file in the context of Emacs typically refers to reading the file and then evaluating its contents as Elisp code, which is the case here.

** Inspiration & Reference

- [[https://github.com/daviwil/emacs-from-scratch][Emacs from Scratch]], a build-along configuration and video series by [[https://youtube.com/c/SystemCrafters][David Wilson]] of System Crafters
- Words, spoken and written, from [[https://protesilaos.com/emacs/][Protesilaos Stavrou]], aka /Prot/

* Package Management

The [[https://github.com/jwiegley/use-package][use-package]] macro is invaluable for keeping the generated configuration code tidy and performant. The following installs it and ensures that packages in =use-package= forms are installed automatically using =straight.el=.

#+begin_src emacs-lisp
  (straight-use-package 'use-package)
  (setq straight-use-package-by-default t)
#+end_src

* Defaults

#+begin_src emacs-lisp
  ;; Keep buffers in sync with external changes
  (global-auto-revert-mode 1)

  ;; Save place in files
  (save-place-mode t)

  ;; Remember recently-visited files
  (recentf-mode t)

  (setq-default tab-width 2)
  (setq-default evil-shift-width tab-width)
  (setq-default indent-tabs-mode nil)

  ;; TODO Wrangle custom file
  ;; TODO Wrangle transient files
#+end_src

The following customizes some basic behaviors of Emacs itself:

#+begin_src emacs-lisp
  (use-package emacs
    :custom
    (confirm-kill-emacs #'yes-or-no-p "Confirm before quitting")
    (custom-file (locate-user-emacs-file "custom-vars.el") "Set custom file path")
    (frame-resize-pixelwise t)
    (gc-cons-threshold (* 2 1000 1000) "Make GC pauses faster by decreasing threshold")
    (history-length 40 "Maximum number of files to keep in history")
    (message-kill-buffer-query nil "Don't ask to confirm buffer kill")
    (use-short-answers t "Abbreviate yes/no input")
    (window-resize-pixelwise t))
#+end_src


I use the savehist package to remember prompt inputs between sessions.

#+begin_src emacs-lisp
  (use-package savehist
    :init
    (setq history-length 40)
    (savehist-mode))
#+end_src

Tell Emacs a little about myself:

#+begin_src emacs-lisp
  (setq user-full-name "Nicholas Scheurich"
        user-mail-address "nick@scheurich.haus")
#+end_src

I prefer to bypass the Emacs splash screen and boot to the scratch buffer by default.

#+begin_src emacs-lisp
  (setq inhibit-startup-message t)
#+end_src

TODO:

#+begin_src emacs-lisp
  (setq ring-bell-function 'ignore)
  (electric-pair-mode t)
#+end_src

* Editing

https://github.com/abo-abo/avy

#+begin_src emacs-lisp
  (use-package avy
    :after evil
    :bind (:map evil-normal-state-map
                ("s" . 'avy-goto-char-2)
                ("f"  . 'evil-avy-goto-char-in-line)))
#+end_src

https://github.com/rolandwalker/simpleclip

#+begin_src emacs-lisp
  (use-package simpleclip
     :bind
     (("M-c" . simpleclip-copy)
      ("M-v" . simpleclip-paste))
     :config
     (simpleclip-mode 1))
#+end_src

* Typography

My preferred monospaced programming font these days is [[https://www.monolisa.dev/][MonoLisa]] by [[https://www.facetype.org/][Marcus Sterz]]. I set this font as the default and slightly increase the leading.

#+begin_src emacs-lisp
  (set-face-attribute 'default nil :font "MonoLisa" :height 110)
  (setq-default line-spacing 0.2)
#+end_src

* User Interface

** Themes

I use the [[https://protesilaos.com/emacs/modus-themes][Modus (My Old Display Unexpectedly Sharpened) themes]] by Protesilaos Stavrou, which are optimized for maximum color-contrast accessibility. The basic Modus themes are distributed with Emacs as of version 28.1. However, I prefer the /tinted/ variants and so load the package from ELPA.

I use the [[https://github.com/GuidoSchmidt/circadian.el][circadian]] package to load the dark-on-light theme (=modus-operandi-tinted=) or the light-on-dark theme (=modus-vivendi-tinted=) based on the time of day.

#+begin_src emacs-lisp
  (use-package modus-themes)

  (use-package circadian
    :config
    (setq circadian-themes '(("07:30" . modus-operandi-tinted)
                             ("19:30" . modus-vivendi-tinted)))
    (circadian-setup))
#+end_src

** Line Numbers

Quickly referencing line number is a huge convenience when viewing and editing source code, so I enable =display-line-numbers-mode= for programming mode buffers.

#+begin_src emacs-lisp
(add-hook 'prog-mode-hook #'display-line-numbers-mode)
#+end_src

** Mode Line

#+begin_src emacs-lisp
  (setq column-number-mode t)
#+end_src

** Eldoc

Prevent Eldoc from resizing the echo area:

#+begin_src emacs-lisp
  (use-package eldoc
    :ensure nil
    :init
    (setq eldoc-echo-area-use-multiline-p nil))
#+end_src

** Popper

https://github.com/karthink/popper

#+begin_src emacs-lisp
  (use-package popper
    :bind (("C-`"   . popper-toggle-latest)
     ("M-`"   . popper-cycle)
     ("C-M-`" . popper-toggle-type))
    :init
    (setq popper-reference-buffers
    '("\\*Messages\\*"
      "Output\\*$"
      "\\*Async Shell Command\\*"
      help-mode
      compilation-mode))
    (popper-mode +1)
    (popper-echo-mode +1))
#+end_src

** Solaire

https://github.com/hlissner/emacs-solaire-mode

#+begin_src emacs-lisp
  ;; TODO Turn on Modus solaire-mode support
  (use-package solaire-mode
    :config (solaire-global-mode +1))
#+end_src

** Treemacs

https://github.com/Alexander-Miller/treemacs

#+begin_src emacs-lisp
  (use-package treemacs)
#+end_src

** which-key

https://github.com/justbur/emacs-which-key

#+begin_src emacs-lisp
  (use-package which-key
    :config
    (which-key-mode))
#+end_src

** Folding

<https://github.com/gregsexton/origami.el>

#+begin_src emacs-lisp
  (use-package origami)
#+end_src

** Rainbow Delimiters

https://github.com/Fanael/rainbow-delimiters

#+begin_src emacs-lisp
  (use-package rainbow-delimiters
    :hook (prog-mode . rainbow-delimiters-mode))
#+end_src

* Completion

In Emacs, a /completion system/ is a mechanism that surfaces a subset of items from some initial list based on user input. For instance, given a set of English words and an input of "comp", a completion system might return a list of words that begin with the letter sequence c-o-m-p, e.g. /complete/, /comprehensive/, /computer/.

The initial set of items, or /candidates/, is typically sourced based on the most recent action: `=find-file=` uses a set of files and directories, `=describe-function` uses the set of known functions, etc.

I augment Emacs’ built-in completion systems with some excellent community packages:

- [[https://github.com/minad/vertico][Vertico]]
- [[https://github.com/oantolin/orderless][Orderless]]
- [[https://github.com/minad/marginalia][Marginalia]]
- [[https://github.com/minad/consult][Consult]]
- [[https://github.com/minad/corfu][Corfu]]

** TODO Cape

** Vertico
  
*Vertico* (VERTical Interactive COmpletion) enhances the built-in completion commands with an extensible vertical selection UI, sorting configurability affordances, support for annotations, and more. It’s a great upgrade out of the box and maintains full compatibility with the standard Emacs completion experience, thus reducing the likelihood of seeing unexpected behavior.

#+begin_src emacs-lisp
  (use-package vertico
    :init (vertico-mode))
#+end_src

** Marginalia

*Marginalia* adds rich annotations to completion candidates: 

- Descriptions of commands
- Filesystem details for files
- Value and description of variables

  #+begin_src emacs-lisp
    (use-package marginalia
      :init (marginalia-mode))
  #+end_src

** Consult

*Consult* adds a set of commands that provide interesting candidate sources and enhance existing ones. There are lots of great functions provided covering buffer-switching, grepping, Org navigation, and more.

#+begin_src emacs-lisp
  (use-package consult
    :bind (("C-x b" . consult-buffer)
	   ("M-s l" . consult-line)))
#+end_src

** Corfu

*Corfu* (Completion Overlay Region FUnction) enhances completion at point, i.e. completion that occurs at the location of the cursor, with a pop-up completion UI. I load and enable =corfu-popupinfo=, an included extension that displays information for the selected completion candidate beside the candidate list.

#+begin_src elisp
    (defvar ngs/corfu-extensions-directory
      (format "%sstriaght/build/corfu/extensions" user-emacs-directory)
      "Path to Corfu’s included extensions")

    (use-package corfu
      :load-path ngs/corfu-extensions-directory
      :custom
      (corfu-auto t)
      :bind
      (:map corfu-map ("SPC" . corfu-insert-separator))
      :init
      (global-corfu-mode))
      ;; (require 'corfu-popupinfo)
      ;; (corfu-popupinfo-mode))
#+end_src

** Orderless

*Orderless* provides a completion style that allows a pattern to be divided into chunks that can be matched in any order. For instance, =buf cons= and =cons buf= will both match =consult-buffer=.

#+begin_src emacs-lisp
  (use-package orderless
    :init
    (setq completion-styles '(orderless)))
#+end_src

* Evil

Having near-perfect Vim emulation is a prime requirement for any platform with which I will be doing heavy text editing. Luckily [[https://github.com/emacs-evil/evil][Evil]], the *extensible vi layer* for Emacs is superb.

#+begin_src  emacs-lisp
  (use-package evil
    :custom
    ;; TODO Document customizations
    (evil-echo-state nil)
    (evil-undo-system 'undo-redo)
    (evil-want-C-i-jump t)
    (evil-want-C-u-scroll t)
    (evil-want-Y-yank-to-eol t)
    (evil-want-fine-undo t)
    (evil-want-integration t)
    (evil-want-keybinding nil)
    :config
    (evil-mode 1))

  ;; Rebind `universal-argument' to 'C-M-u' since 'C-u' now scrolls the buffer
  (global-set-key (kbd "C-M-u") 'universal-argument)
#+end_src

** Evil Collection

There are parts of Emacs, e.g. =help-mode=, =M-x calendar=, Eshell, which are not covered by Evil. [[https://github.com/emacs-evil/evil-collection][Evil Collection]] is a community-sourced collection of Evil bindings that aims to provide a consistent Evil experience throughout Emacs.

TODO List Vim packages that Evil emulates.

#+begin_src emacs-lisp
  (use-package evil-collection
    :after evil
    :config
    (evil-collection-init))
#+end_src

** Evil Commentary

#+begin_src emacs-lisp
  (use-package evil-commentary
    :after evil
    :config
    (evil-commentary-mode))
#+end_src

* Keybindings

#+begin_src emacs-lisp
  ;; macOS-specific modifier tweaks
  (if (eq system-type 'darwin)
      ;; Use command key as meta
      (setq mac-command-modifier 'meta)

      ;; Map option key to super
      (setq mac-option-modifier 'super))

  ;; Make <escape> quit prompts
  (global-set-key (kbd "<escape>") 'keyboard-escape-quit)

  ;; Remap help prefix
  (global-set-key (kbd "C-c h") 'help-command)

  ;; Map right Option key to Super
  (setq mac-right-option-modifier 'super)

  ;; General
  (use-package general
    :config
    (general-evil-setup)

    (general-create-definer ngs/leader-def
      :keymaps '(normal emacs)
      :prefix "SPC")

    (ngs/leader-def
      "f"   '(:ignore t :which-key "find")
      "SPC" '(consult-buffer :which-key "buffer")
      "/"   '(consult-line :which-key "line")
      "ff"  '(project-find-file :which-key "file")
      "fg"  '(consult-grep :which-key "grep")
      "fl"  '(consult-line :which-key "line")
      "fr"  '(consult-recent-file :which-key "recent")
      "fb"  '(consult-buffer :which-key "buffer")

      "p"  '(:ignore t :which-key "project")
      "pf" '(project-find-file :which-key "find file")
      "pk" '(project-kill-buffers :which-key "kill buffers")
      "pp" '(project-switch-project :which-key "switch")

      "g"  '(:ignore g :which-key "git")
      "gs" '(magit-status :which-key "status")

      "h"  '(:ignore g :which-key "help")
      "hh" '(helpful-at-point :which-key "at point")
      "hf" '(helpful-callable :which-key "function")
      "hc" '(helpful-command :which-key "command")
      "hk" '(helpful-key :which-key "key")
      "hK" '(describe-keymap :which-key "keymap")
      "hm" '(describe-mode :which-key "mode")
      "hv" '(helpful-variable :which-key "variable")

      "t"  '(:ignore t :which-key "toggles")
      "tt" '(treemacs :which-key "treemacs")))
#+end_src

* Languages

I employ a number of programming language modes to provide syntax highlighting and other useful functions related to code I work with.

#+begin_src emacs-lisp
  (use-package elixir-ts-mode)
  (use-package json-mode)
  (use-package lua-mode)
  (use-package markdown-mode)
  (use-package nix-mode :mode "\\.nix\\'")
#+end_src

* Language Server Protocol

#+begin_src elisp
  (defvar ngs/language-server-programs
    '((elixir . '("~/Projects/elixir-ls/release/language_server.sh")))
    "Locations of LSP server binaries")

  (defun ngs/language-server-program (language)
    (cdr (assoc language ngs/language-server-programs)))
#+end_src

#+begin_src emacs-lisp
  (use-package eglot
    :config
    (add-to-list 'eglot-server-programs
		 '(elixir-ts-mode  "~/Projects/elixir-ls/release/language_server.sh"))
    :hook
    ((elixir-mode . eglot-ensure)))
#+end_src

* Shells

https://github.com/akermu/emacs-libvterm
https://github.com/suonlight/multi-vterm

#+begin_src emacs-lisp
  (use-package vterm)
  (use-package multi-vterm)
#+end_src

* Org Mode

#+begin_src emacs-lisp
  (defun ngs/org-mode-visual-fill ()
    (setq visual-fill-column-width 100
	  visual-fill-column-center-text t)
    (visual-line-mode 1)
    (visual-fill-column-mode 1))

  (use-package visual-fill-column
    :hook (org-mode . ngs/org-mode-visual-fill))
#+end_src

