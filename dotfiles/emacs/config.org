#+TITLE: GNU Emacs Configuration
#+AUTHOR: N. G. Scheurich
#+EMAIL: nick@scheurich.haus
#+PROPERTY: header-args :tangle ./init.el

* Contents                                                              :TOC:
- [[#preface][Preface]]
  - [[#inspiration--reference][Inspiration & Reference]]
- [[#configuration-tangling][Configuration Tangling]]
  - [[#why-cant-i-use-user-emacs-directory-to-evaluate-the-file-path][Why can't I use ~user-emacs-directory~ to evaluate the file path?]]
- [[#package-management][Package Management]]
  - [[#straightel][straight.el]]
  - [[#use-package][use-package]]
- [[#basics][Basics]]
  - [[#emacs][Emacs]]
  - [[#temporary-files][Temporary Files]]
- [[#environment][Environment]]
- [[#evil][Evil]]
  - [[#evil-collection][Evil Collection]]
  - [[#supplements][Supplements]]
- [[#keybindings][Keybindings]]
  - [[#general][General]]
- [[#org-mode][Org Mode]]
- [[#dired][Dired]]
  - [[#this-doesnt-even-work-][This doesn't even work... üò•]]
- [[#version-control][Version Control]]

* Preface
This is my personal *GNU Emacs* configuration. It‚Äôs an [[https://orgmode.org/][Org Mode]] document written in a [[https://en.wikipedia.org/wiki/Literate_programming][literate programming]] style, with text meant for computer interpretation, i.e. /code/, intermingled with plain-language text meant to be parsed by humans. I find that this paradigm works nicely here, as it allows me to colocate my thoughts about parts of the setup along with the Emacs Lisp (Elisp) configuration code itself.

From a technical perspective, when this file is written to disk, each code block in the document is /tangled/ (exported using to a file using =org-babel-tangle=). Most blocks are exported to the default Emacs initialization file, =init.el=. This process is elaborated on further in the [[*Configuration Tangling][Configuration Tangling]] section.

** Inspiration & Reference
Configuring Emacs can be quite the journey and, if not for amazing prior art and community support, I may not have set foot on the road. From the official manual to [[https://www.reddit.com/r/emacs/][r/emacs]], there is a wealth of support out there for the budding Emacs user. I‚Äôd like to call out a few particularly helpful folks and resources:

- [[https://github.com/daviwil/emacs-from-scratch][Emacs from Scratch]], a video series and config by [[https://daviwil.com/][David Wilson]] of [[https://youtube.com/c/SystemCrafters][System Crafters]]
- Words, spoken and written, by [[https://protesilaos.com/emacs/][Protesilaos Stavrou]], aka /Prot/
- [[https://www.masteringemacs.org/][Mastering Emacs]], a book and blog series by [[https://www.masteringemacs.org/about][Mickey Petersen]]
- [[https://github.com/jasonmj/.emacs.d][Configuration]] by and conversation with [[https://github.com/jasonmj][Jason Johnson]]

Lastly, thanks to [[https://github.com/jkwascom][Joshua Wascom]], whose mentorship helped me understand the value of investing in customizable, well-integrated tools.

\* This is not meant to be an [[https://github.com/oantolin/embark][Embark]] pun, but the reader may think of it that way if they so choose.

* Configuration Tangling
The following code defines a function that checks whether we are currently visiting a buffer for this file (that is to say, the =config.org= file in ~user-emacs-directory~) and, if so, tangles each code block in the file. It also attaches a hook to ~after-save-hook~ to call the function after the buffer is saved.

** TODO Why can't I use ~user-emacs-directory~ to evaluate the file path?

#+begin_src emacs-lisp
(defun ngs-org-babel-tangle-config ()
  (when (string-equal (buffer-file-name)
                      "/etc/system/dotfiles/emacs/config.org")
    (let ((org-confirm-babel-evaluate nil))
      (org-babel-tangle)
      (message "Tangled config files."))))

(add-hook 'org-mode-hook (lambda ()
   (add-hook 'after-save-hook #'ngs-org-babel-tangle-config)))
#+end_src

* Package Management
** straight.el
Emacs has a built-in packager, package.el, but I prefer [[https://github.com/radian-software/straight.el][straight.el]] for a few key reasons:

- It affords the ability to use a specific Git revision of a package
- It only loads the packages specified in this configuration file
- It supports true portabilty/reproducibility via lockfiles
- It allows me to easily make ad-hoc changes to packages

There are further advantages, and some disadvantages, when compared to package.el which are enumerated in straight.el‚Äôs [[https://github.com/raxod502/straight.el#comparison-to-packageel][README]].

First, we must prevent package.el from loading any packages.

#+begin_src emacs-lisp
  (setq package-enable-at-startup nil)
#+end_src

Finally we bootstrap straight.el, which involves downloading and evaluating the installation file it if it is not detected. See [[https://github.com/radian-software/straight.el#getting-started][the /Getting started/ guide]].

#+begin_src emacs-lisp
(defvar bootstrap-version)
(let ((bootstrap-file
       (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
      (bootstrap-version 5))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
  (url-retrieve-synchronously
   "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
   'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))
#+end_src

** use-package
The [[https://www.gnu.org/software/emacs/manual/html_mono/use-package.html][~use-package~]] macro is invaluable for keeping configuration code tidy and performant. The following ensures that packages in =use-package= forms are installed automatically using =straight.el=.

#+begin_src emacs-lisp
(straight-use-package 'use-package)
(setq straight-use-package-by-default t)
#+end_src

* Basics
** Emacs

#+begin_src emacs-lisp
(use-package emacs
  :ensure nil
  :config
  (setq user-emacs-directory "=/.config/emacs/")
  :custom
  (custom-file (locate-user-emacs-file "custom-vars.el") "Set custom file path")
  (frame-resize-pixelwise t "Resize frames by pixels rather than characters")
  (gc-cons-threshold (* 2 1000 1000) "Make GC pauses faster by decreasing threshold")
  (history-length 40 "Maximum number of files to keep in history")
  (inhibit-startup-message t "Bypass the Emacs splash screen")
  (message-kill-buffer-query nil "Don't ask to confirm buffer kill")
  (ring-bell-function 'ignore "Suppress the bell")
  (use-short-answers t "Abbreviate yes/no input")
  (user-email-address "nick@scheurich.haus" "My personal email address")
  (user-full-name "Nicholas Scheurich" "My full name")
  (window-resize-pixelwise t "Resize windows by pixels rather than characters"))
#+end_src

** Temporary Files
Emacs and its packages generate lots of ancillary files. By default, auto-save and backup files are stored alongside the files they target, which I think is utter madness. Additionally, both built-in and third-party packages are inconsistent in their decisions about where to put data. This can all lead to an Emacs session leaving behind a mess of files strewn haphazardly across your file system. We can do better.

The handy [[https://github.com/emacscollective/no-littering][no-littering]] package will take care of setting paths for /many/, but not all, built-in and third-party packages. I use the default settings, which uses =user-emacs-directory= as a base path and then sets up =etc= for configuration files and =var= for persistent data. For me, this ends up looking like:

- =$HOME/.config/emacs/etc= for configuration files
- =$HOME/.config/emacs/var= for persistent data

#+begin_src emacs-lisp
(use-package no-littering)
#+end_src

With that squared away, we can use the =no-littering-expand-var-file-name= path to set auto-save and backup files to be stored in the same place as other persistent data.

#+begin_src emacs-lisp
(defvar ngs-auto-save-directory
  (no-littering-expand-var-file-name "auto-save/")
  "Directory in which auto-save files should be stored")

(defvar ngs-backup-directory
  (no-littering-expand-var-file-name "backup/")
  "Directory in which backup files should be stored")

(mapcar (lambda (dir)
          (unless (file-directory-p dir)
            (make-directory dir)))
        `(,ngs-auto-save-directory ,ngs-backup-directory))

(setq auto-save-file-name-transforms
      `((".*" ,ngs-auto-save-directory t)))

(setq backup-directory-alist
      `((".*" . ,ngs-backup-directory)))
#+end_src

* Environment
Depending on how Emacs is launched, the environment variables it inherits may not be the ones that you set up in your favorite shell, e.g. =zsh=, =fish=. This often leads to undesirable behavior such as Emacs not being able to locate external programs.

[[https://github.com/purcell/exec-path-from-shell][exec-path-from-shell]] teaches Emacs about the environment variables that your =$SHELL= exports.

#+begin_src emacs-lisp
  (use-package exec-path-from-shell
    :config
    (exec-path-from-shell-initialize))
#+end_src

I often use [[https://direnv.net/][direnv]] to manage project-specific environment variable. [[https://github.com/purcell/envrc][envrc.el]] provides buffer-local direnv integration by updating things like =process-environment= and =exec-path=.

#+begin_src emacs-lisp
(use-package envrc
  :config
  (envrc-global-mode))
#+end_src

* Evil
I‚Äôve been a [[https://www.vim.org/][Vim]] (or [[https://neovim.io/][Neovim]]) user for many years. Its concept of modality really clicked with me and the /count + operator + motion/text object/ grammar is built into my fingers at this point. I think editing the ‚ÄúEmacs way‚Äù probably offers a good experience, but for me, comprehensive Vim emulation is a prime requirement for any text-centric platform I use.

Luckily [[https://github.com/emacs-evil/evil][Evil]], an *extensible vi layer* for Emacs, is superb. It does a great job of emulating Vim‚Äôs text editing modes, while also implementing a command-line mode and many common Vim commands, e.g. =:write=, =:normal=, =:registers=, =read=, =:!shell-command=. Importantly, it also offers an API for defining one‚Äôs own motions, text objects, etc.

Note that in the ~:config~ section below, the /universal argument/ keybinding is changed to =C-M-u=. This is because =C-u= is set to scroll up half a page as it does in Vim (~evil-want-C-u-scroll~).

#+begin_src  emacs-lisp
(use-package evil
  :custom
  (evil-echo-state nil "Don't display the Evil state in the echo area")
  (evil-undo-system 'undo-redo "Use the Emacs-native undo/redo functionality")
  (evil-want-C-i-jump t "'C-i' to jump to next location")
  (evil-want-C-u-scroll t "'C-u' to scroll by half a page")
  (evil-want-Y-yank-to-eol t "'Y' to yank to the end of the line")
  (evil-want-keybinding nil "Don't load bindings for additional modes (see 'Evil Collection')")
  :general
  ("C-M-u" 'universal-argument)
  (general-nmap
    "<up>" 'evil-window-up
    "<down>" 'evil-window-down
    "<left>" 'evil-window-left
    "<right>" 'evil-window-right
    "-" 'dired-jump)
  :config
  (evil-mode 1))
#+end_src

** Evil Collection
There are parts of Emacs, e.g. =help-mode=, =M-x calendar=, Eshell, which are not covered by Evil. Additionally, most third-party packages are not designed with Evil in mind. [[https://github.com/emacs-evil/evil-collection][Evil Collection]] is a community-sourced collection of Evil bindings that aims to provide a consistent Evil experience throughout Emacs.

It also emulates many of the keybindings from [[https://tpo.pe/][Tim Pope]]‚Äôs [[https://github.com/tpope/vim-unimpaired][unimpaired.vim]], which I‚Äôve always found super useful.

#+begin_src emacs-lisp
(use-package evil-collection
  :after evil
  :config
  (evil-collection-init))
#+end_src

** Supplements
[[https://github.com/emacs-evil/evil-surround][evil-surround]] mimics the functionality of [[https://github.com/tpope/vim-surround][surround.vim]].

#+begin_src emacs-lisp
  (use-package evil-surround
    :after evil
    :config
    (global-evil-surround-mode 1))
#+end_src

[[https://github.com/linktohack/evil-commentary][evil-commentary]] mimics the functionality of [[https://github.com/tpope/vim-commentary][commentary.vim]].

#+begin_src emacs-lisp
  (use-package evil-commentary
    :diminish
    :after evil
    :config
    (evil-commentary-mode))
#+end_src

[[https://github.com/emacs-evil/evil-cleverparens][evil-cleverparens]] optimizes modal editing for Lisp.

#+begin_src emacs-lisp
  (use-package evil-cleverparens
    :diminish
    :after evil
    :config
    (evil-cleverparens-mode))
#+end_src

* Keybindings
** General
Just as =use-package= provides convenient macros for managing packages, so does [[https://github.com/noctuid/general.el][General]] for defining keybindings.

In addition to installing and setting up the package I also create two /definers/ meant to mimic Vim‚Äôs [[https://neovim.io/doc/user/map.html#%3CLeader%3E][<Leader>]] and [[https://neovim.io/doc/user/map.html#%3CLocalLeader%3E][<LocalLeader>]] prefix keys. The definers, =ngs-leader-def= and =ngs-local-leader-def= are mapped to the =SPC= and =,= keys, respectively.

#+begin_src emacs-lisp
(use-package general
  :init
  (setq general-override-states '(insert
                                  emacs
                                  hybrid
                                  normal
                                  visual
                                  motion
                                  operator
                                  replace))
  :config
  (general-evil-setup)

  (general-create-definer ngs-leader-def
    :keymaps '(normal emacs)
    :prefix "SPC")

  (general-create-definer ngs-local-leader-def
    :keymaps '(normal emacs)
    :prefix ","))
#+end_src

* Org Mode
#+begin_src emacs-lisp
(use-package toc-org
  :hook (org-mode . toc-org-mode))
#+end_src

* Dired
Dired is the built-in Emacs file manager. It is quite powerful, but has some quirks.

Normally, after a file operation is performed, one must manually refresh the directory listing using ~dired-do-redisplay~. By setting ~dired-do-revert-buffer~ to true, the refresh will happen automatically in /some/ cases, but not all. To handle any dired buffer update, I add a hook to ~dired-mode-hook~.

** TODO This doesn't even work... üò•

#+begin_src emacs-lisp
(add-hook 'dired-mode-hook 'auto-revert-mode)
#+end_src

* Version Control
The centerpiece of my version control setup is the excellent [[https://magit.vc/][Magit]] package.

#+begin_src emacs-lisp
(use-package magit
  :general
  (ngs-leader-def
    "gb" '(magit-blame :which-key "blame")
    "gl" '(magit-log :which-key "log")
    "gg" '(magit-status :which-key "git")))
#+end_src
