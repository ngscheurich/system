#+TITLE: GNU Emacs Configuration
#+AUTHOR: N. G. Scheurich
#+EMAIL: nick@scheurich.haus

* Introduction

This is my primary *GNU Emacs* configuration file. I say /primary/ because two other files, =early-init.el= and =init.el=, round out the whole of my configuration, though their purposes are tightly constrained and explained in more detail in each file.

This file is an [[https://orgmode.org/][Org Mode]] document written in a [[https://en.wikipedia.org/wiki/Literate_programming][literate programming]] style, with text meant for computer interpretation, i.e. /code/, intermingled with plain-language text meant to be parsed by humans. I find that this paradigm lends itself nicely to system configuration, as it allows me to colocate my thoughts about parts of the config along with the Emac Lisp (Elisp) configuration code itself. Hopefully this colocation will make the myriad functions of this file easier to narrow in on and parse by others, my future self included.

From a technical perspective, when Emacs is started each code block in this document is /tangled/ (exported using to a file using =org-babel-tangle=) and then loaded using =load-file=. Note that /loading/ a file in the context of Emacs typically refers to reading the file and then evaluating its contents as Elisp code, which is the case here.

** Inspiration & Reference

- [[https://github.com/daviwil/emacs-from-scratch][Emacs from Scratch]], a build-along configuration and video series by [[https://youtube.com/c/SystemCrafters][David Wilson]] of System Crafters
- Words, spoken and written, from [[https://protesilaos.com/emacs/][Protesilaos Stavrou]], aka /Prot/

* Basic Settings

Tell Emacs a little about myself:

#+begin_src emacs-lisp
  (setq user-full-name "Nicholas Scheurich"
        user-mail-address "nick@scheurich.haus")
#+end_src

I prefer to bypass the Emacs splash screen and boot to the scratch buffer by default. Perhaps I’ll find an Emacs package similar to [[https://github.com/mhinz/vim-startify][Startify]] and switch to that at some point.

#+begin_src emacs-lisp
  (setq inhibit-startup-message t)
#+end_src

There will be no bell-ringing of any sort inside of my Emacs.

#+begin_src emacs-lisp
  (setq ring-bell-function 'ignore)
#+end_src

* Package Management

The [[https://github.com/jwiegley/use-package][use-package]] macro is invaluable for keeping my config tidy and performant. The following installs it and ensures packages in =use-package= forms are installed automatically using =straight.el=.

#+begin_src emacs-lisp
  (straight-use-package 'use-package)
  (setq straight-use-package-by-default t)
#+end_src

* Appearance

** Themes

I use the [[https://protesilaos.com/emacs/modus-themes][Modus themes]] by [[https://protesilaos.com/][Protesilaos Stavrou]], which are optimized for maximum color-contrast accessibility. =modus-operandi=, the dark-on-light Modus theme, is loaded by default. =<f5>= is bound to a function that lets me toggle between the light and dark (=modus-vivendi=) Modus themes. Perhaps in the future I will write a function to load one theme or the other depending on time of day.

#+begin_src emacs-lisp
  (use-package modus-themes
    :init
    (setq modus-themes-common-palette-overrides
	    '((border-mode-line-active unspecified)
	      (border-mode-line-inactive unspecified))))

  ;; Customize mode-line appearance
  (defun my-modus-themes-custom-faces ()
    (modus-themes-with-colors
     (custom-set-faces
      ;; Thicken the mode line
      `(mode-line ((,c :box (:line-width 3 :color ,bg-mode-line-active))))
      `(mode-line-inactive ((,c :box (:line-width 3 :color ,bg-mode-line-inactive)))))))

  (add-hook 'modus-themes-after-load-theme-hook #'my-modus-themes-custom-faces)
  (my-modus-themes-custom-faces)
#+end_src

** Circadian

*** TODO Write description

#+begin_src emacs-lisp
  (use-package circadian
    :ensure t
    :config
    (setq circadian-themes '(("07:30" . modus-operandi-tinted)
			     ("19:30" . modus-vivendi-tinted)))
    (circadian-setup))
#+end_src

** Typography

*** TODO Update font description

My preferred monospaced programming font these days is [[https://www.monolisa.dev/][MonoLisa]] by [[https://www.facetype.org/][FaceType]]. I set this font as the default, slightly increase the leading, and enable ligatures.

#+begin_src emacs-lisp
  (set-face-attribute 'default nil :font "Iosevka" :height 130)
  (setq-default line-spacing 0.2)
#+end_src

*** Ligatures

*** TODO Write description
*** TODO Why do I need to set load-path? (see https://github.com/mickeynp/ligature.el/wiki#iosevka)

#+begin_src emacs-lisp
  (setq ligature-path (straight--repos-dir "ligature"))

  (use-package ligature
    :load-path ligature-path
    :config
    (ligature-set-ligatures 'prog-mode '("<---" "<--"  "<<-" "<-" "->" "-->" "--->" "<->" "<-->"
					 "<--->" "<---->" "<!--" "<==" "<===" "<=" "=>" "=>>" "==>"
					 "===>" ">=" "<=>" "<==>" "<===>" "<====>" "<!---" "<~~"
					 "<~" "~>" "~~>" "::" ":::" "==" "!=" "===" "!==" ":=" ":-"
					 ":+" "<*" "<*>" "*>" "<|" "<|>" "|>" "+:" "-:" "=:"
					 "<******>" "++" "+++"))
    (global-ligature-mode t))
#+end_src

** Line Numbers

#+begin_src emacs-lisp
(add-hook 'prog-mode-hook #'display-line-numbers-mode)
#+end_src

** Mode Line

*** TODO: Write about doom-modeline

#+begin_src emacs-lisp
  ;; (use-package doom-modeline
  ;;   :custom
  ;;   ;; (doom-modeline-bar-width 0)
  ;;   (doom-modeline-buffer-modification-icon nil)
  ;;   (doom-modeline-height 0)
  ;;   (doom-modeline-modal-icon t)
  ;;   :config
  ;;   (doom-modeline-mode 1))

  (setq column-number-mode t)
#+end_src

* Completion

In Emacs, a /completion/ system refers to a facility meant to predict what text the user is going to to type and provide a list of selection candidates based on that prediction.

I augment Emacs’ built-in completion systems with some excellent community packages:

- [[https://github.com/minad/vertico][Vertico]]
- [[https://github.com/oantolin/orderless][Orderless]]
- [[https://github.com/minad/marginalia][Marginalia]]
- [[https://github.com/minad/consult][Consult]]
- [[https://github.com/minad/corfu][Corfu]]

** Vertico
  
*Vertico* (VERTical Interactive COmpletion) enhances the default completion system with an extensible vertical selection UI, sorting configurability affordances, support for annotations, and more. It’s a great upgrade out of the box and maintains full compatibility with the built-in Emacs completion experience, thus reducing the likelihood of seeing unexpected behavior.

#+begin_src emacs-lisp
  (use-package vertico
    :init (vertico-mode))
#+end_src

** Marginalia

*Marginalia* adds rich annotations to completion candidates, e.g.: 

- Descriptions of commands
- Filesystem details for files
- Value and description of variables

  #+begin_src emacs-lisp
    (use-package marginalia
      :init (marginalia-mode))
  #+end_src

** Consult

*Consult* adds a set of commands that provide interesting candidate lists which can be narrowed using completion systems based on the Emacs =completing-read= API—Vertico, for instance. There are lots of great functions provided covering buffer-switching, grepping, Org navigation, and more.

#+begin_src emacs-lisp
  (use-package consult
    :bind (("C-x b" . consult-buffer)
	   ("M-s l" . consult-line)))
#+end_src

** Corfu

*Corfu* (Completion Overlay Region FUnction) enhances completion at point, i.e. completion that occurs at the location of the cursor, with a pop-up completion UI. I load and enable =corfu-popupinfo=, an included extension that displays information for the selected completion candidate beside the Corfu list.

#+begin_src elisp
    (defvar ngs/corfu-extensions-directory
      (format "%sstriaght/build/corfu/extensions" user-emacs-directory)
      "Path to Corfu’s included extensions")

    (use-package corfu
      :load-path ngs/corfu-extensions-directory
      :custom
      (corfu-auto t)
      :bind
      (:map corfu-map ("SPC" . corfu-insert-separator))
      :init
      (global-corfu-mode))
      ;; (require 'corfu-popupinfo)
      ;; (corfu-popupinfo-mode))
#+end_src

** Orderless

*Orderless* provides a completion style that allows a pattern to be divided into chunks that can be matched in any order. For instance, =buf cons= and =cons buf= will both match =consult-buffer=.

#+begin_src emacs-lisp
  (use-package orderless
    :init
    (setq completion-styles '(orderless)))
#+end_src

* Keybindings

Vim’s modal text editing model was eye-opening for me, and changed the way I think about interacting keyboard-based interfaces. Having near-perfect Vim emulation is a prime requirement for any platform with which I will be doing heavy text editing. Luckily [[https://github.com/emacs-evil/evil][Evil]], the *extensible vi layer* for Emacs is superb.

#+begin_src  emacs-lisp
  (use-package evil
    :custom
    (evil-want-keybinding nil)
    (evil-want-C-u-scroll t)
    (evil-undo-system 'undo-redo)
    (evil-echo-state nil)
    :bind
    (:map evil-normal-state-map
	  ("<up>" . 'evil-window-up)
	  ("<down>" . 'evil-window-down)
	  ("<left>" . 'evil-window-left)
	  ("<right>" . 'evil-window-right)
	  ("-" . dired-jump))
    :config
    (evil-mode 1))
#+end_src

There are parts of Emacs, e.g. =help-mode=, =M-x calendar=, Eshell, which are not covered by Evil. [[https://github.com/emacs-evil/evil-collection][Evil Collection]] is a community-sourced collection of Evil bindings that aims to provide a consistent Evil experience throughout Emacs.

#+begin_src emacs-lisp
  (use-package evil-collection
    :after evil
    :config
    (evil-collection-init))
#+end_src

** TODO: Organize this random shit

#+begin_src emacs-lisp
  ;; Make <escape> quit prompts
  (global-set-key (kbd "<escape>") 'keyboard-escape-quit)

  ;; Remap help prefix
  (global-set-key (kbd "C-c h") 'help-command)

  ;; Map right Option key to Super
  (setq mac-right-option-modifier 'super)
#+end_src

* Programming

** Languages

I employ a number of programming language modes to provide syntax highlighting and other useful functions related to code I work with.

#+begin_src emacs-lisp
  (use-package elixir-ts-mode)
  (use-package json-mode)
  (use-package lua-mode)
  (use-package markdown-mode)
  (use-package nix-mode :mode "\\.nix\\'")
#+end_src

** Syntax Checking

#+begin_src emacs-lisp
  ;; Trying flymake instead
  ;; (use-package flycheck
  ;;   :init (global-flycheck-mode))
#+end_src

** Language Server Protocol

#+begin_src elisp
  (defvar ngs/language-server-programs
    '((elixir . '("~/Projects/elixir-ls/release/language_server.sh")))
    "Locations of LSP server binaries")

  (defun ngs/language-server-program (language)
    (cdr (assoc language ngs/language-server-programs)))
#+end_src

#+begin_src emacs-lisp
  (use-package eglot
    :config
    (add-to-list 'eglot-server-programs
		 '(elixir-ts-mode  "~/Projects/elixir-ls/release/language_server.sh"))
    :hook
    ((elixir-mode . eglot-ensure)))
#+end_src

* Org Mode

** TODO: Write-up

#+begin_src emacs-lisp
  (defun ngs/org-mode-visual-fill ()
    (setq visual-fill-column-width 100
	  visual-fill-column-center-text t)
    (visual-line-mode 1)
    (visual-fill-column-mode 1))

  (use-package visual-fill-column
    :hook (org-mode . ngs/org-mode-visual-fill))
#+end_src

