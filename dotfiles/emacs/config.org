#+TITLE: GNU Emacs Configuration
#+AUTHOR: N. G. Scheurich
#+EMAIL: nick@scheurich.haus
#+PROPERTY: header-args :tangle ./init.el

* Introduction

This is my personal *GNU Emacs* configuration. It’s an [[https://orgmode.org/][Org Mode]] document written in a [[https://en.wikipedia.org/wiki/Literate_programming][literate programming]] style, with text meant for computer interpretation, i.e. /code/, intermingled with plain-language text meant to be parsed by humans. I find that this paradigm works nicely here, as it allows me to colocate my thoughts about parts of the setup along with the Emacs Lisp (Elisp) configuration code itself.

From a technical perspective, when this file is written to disk each code block in the document is /tangled/ (exported using to a file using ~org-babel-tangle~). Most blocks are exported to the default Emacs initialization file, =init.el=.

** Inspiration & Reference

- [[https://github.com/daviwil/emacs-from-scratch][Emacs from Scratch]], a configuration and video series by [[https://daviwil.com/][David Wilson]] of [[https://youtube.com/c/SystemCrafters][System Crafters]]
- Words, spoken and written, by [[https://protesilaos.com/emacs/][Protesilaos Stavrou]], aka /Prot/

* Package Management

** straight.el

Emacs has a built-in packager, =package.el=, but I prefer to use [[https://github.com/radian-software/straight.el][=straight.el=]] for a few key reasons:

- It affords the ability to use a specific Git revision of a package
- It only loads the packages specified in this configuration file
- It supports true portabilty/reproducibility via lockfiles
- It allows me to easily make ad-hoc changes to packages

There are further advantages, and some disadvantages, when compared to =package.el= which are enumerated in straight.el’s [[https://github.com/raxod502/straight.el#comparison-to-packageel][README]].

First, we must prevent =package.el= from loading any packages.

#+begin_src emacs-lisp :tangle ./early-init.el
  (setq package-enable-at-startup nil)
#+end_src

Finally we bootstrap =straight.el=, which involves downloading and evaluating the installation file it if it is not detected. See <https://github.com/raxod502/straight.el#getting-started>.

#+begin_src emacs-lisp :tangle ./early-init.el
  (defvar bootstrap-version)
  (let ((bootstrap-file
         (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
        (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
    (url-retrieve-synchronously
     "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
     'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))
#+end_src

** use-package

The [[https://github.com/jwiegley/use-package][use-package]] macro is invaluable for keeping configuration code tidy and performant. The following installs it and ensures that packages in =use-package= forms are installed automatically using =straight.el=.

#+begin_src emacs-lisp
  (straight-use-package 'use-package)
  (setq straight-use-package-by-default t)
#+end_src

* Basic Settings

** Emacs

There are a series of built-in customizable variables that I change to better suit my personal tastes and workflows.

#+begin_src emacs-lisp
  (use-package emacs
    :ensure nil
    :custom
    (confirm-kill-emacs #'yes-or-no-p "Confirm before quitting")
    (custom-file (locate-user-emacs-file "custom-vars.el") "Set custom file path")
    (frame-resize-pixelwise t "Resize frames by pixels rather than characters")
    (gc-cons-threshold (* 2 1000 1000) "Make GC pauses faster by decreasing threshold")
    (history-length 40 "Maximum number of files to keep in history")
    (inhibit-startup-message t "Bypass the Emacs splash screen")
    (message-kill-buffer-query nil "Don't ask to confirm buffer kill")
    (ring-bell-function 'ignore "Suppress the bell")
    (use-short-answers t "Abbreviate yes/no input")
    (user-email-address "nick@scheurich.haus" "My email address")
    (user-full-name "Nicholas Scheurich" "My full name")
    (window-resize-pixelwise t "Resize windows by pixels rather than characters"))
#+end_src

** Modes

=global-auto-revert-mode= automatically update the contents of certain buffers when their respective files change on disk.

#+begin_src emacs-lisp
  (global-auto-revert-mode 1)
#+end_src

=save-place-mode= saves the last position in file buffers.

#+begin_src emacs-lisp
  (save-place-mode t)
#+end_src

=recentf-mode= remembers recently-visited files, which can be selected from using the =recentf= interactive function.

#+begin_src emacs-lisp
  (recentf-mode t)
#+end_src

=winner-mode= allows the user to undo and redo window layout changes, which is super handy when dealing with Emacs’s often unpredictable windowing system.

#+begin_src emacs-lisp
  (winner-mode 1)
#+end_src

** Packages

*** savehist

The built-in =savehist= package remembers prompt inputs between sessions, thereby creating a persistent command history.

#+begin_src emacs-lisp
  (use-package savehist
    :ensure nil
    :init
    (setq history-length 40)
    (savehist-mode))
#+end_src

*** ElDoc

TODO Describe ElDoc

#+begin_src emacs-lisp
  (use-package eldoc
    :ensure nil
    :init
    (setq eldoc-echo-area-use-multiline-p nil))
#+end_src

** Environment

*** exec-path-from-shell

[[https://github.com/purcell/exec-path-from-shell][exec-path-from-shell]] teaches Emacs about the environment variables that your ~$SHELL~ exports. This helps avoid problems like not being able to locate certain programs.

#+begin_src emacs-lisp
  (use-package exec-path-from-shell
    :config
    (exec-path-from-shell-initialize))
#+end_src

*** emacs-direnv

[[https://github.com/wbolster/emacs-direnv][emacs-direnv]] provides [[https://direnv.net/][direnv]] integration by updating ~process-environment~ and ~exec-path~ based on =direnv=’s evaluation.

#+begin_src emacs-lisp
  (use-package direnv
    :config
    (direnv-mode))
#+end_src

* User Interface

The Emacs user interface is endlessly customizable. For starters, I disable some unwanted UI elements, namely the tool bar and scroll bar.

#+begin_src emacs-lisp
  (tool-bar-mode -1)
  (scroll-bar-mode -1)
#+end_src

** Typography

My preferred monospaced programming font these days is [[https://www.monolisa.dev/][MonoLisa]] by [[https://www.facetype.org/][Marcus Sterz]]. I set this font as the default and slightly increase the leading.

#+begin_src emacs-lisp
  (set-face-attribute 'default nil :font "MonoLisa" :height 110)
  (setq-default line-spacing 0.2)
#+end_src

** Themes

I use the [[https://protesilaos.com/emacs/modus-themes][Modus themes]] by Protesilaos Stavrou, which are optimized for color-contrast accessibility. The basic Modus themes are distributed with Emacs as of version 28.1. However, I prefer the /-tinted/ variants and so load the package from ELPA.

#+begin_src emacs-lisp
  (use-package modus-themes)
#+end_src

The [[https://github.com/GuidoSchmidt/circadian.el][Circadian]] package loads the dark-on-light Modus theme (=modus-operandi-tinted=) or the light-on-dark one (=modus-vivendi-tinted=) based on the time of day.

#+begin_src emacs-lisp
  (use-package circadian
    :config
    (setq circadian-themes '(("07:30" . modus-operandi-tinted)
                             ("19:30" . modus-vivendi-tinted)))
    (circadian-setup))
#+end_src

** Line Numbers

Quickly referencing line numbers is a huge convenience when viewing and editing source code, so I enable =display-line-numbers-mode= for programming mode buffers.

#+begin_src emacs-lisp
(add-hook 'prog-mode-hook #'display-line-numbers-mode)
#+end_src

** Mode Line

#+begin_src emacs-lisp
  (setq column-number-mode t)
#+end_src

* Workspace

** Perspective

[[https://github.com/nex3/perspective-el][Perspective]] provides multiple named workspaces.

#+begin_src emacs-lisp
  (use-package perspective
    :custom
    (persp-mode-prefix-key (kbd "C-x x"))
    :init (persp-mode))

#+end_src


* Evil

Having near-perfect Vim emulation is a prime requirement for any platform with which I will be doing heavy text editing. Luckily [[https://github.com/emacs-evil/evil][Evil]], the *extensible vi layer* for Emacs is superb.

TODO List Vim packages that Evil emulates.

#+begin_src  emacs-lisp
  (use-package evil
    :custom
    (evil-echo-state nil "Don't display the Evil state in the echo area")
    (evil-undo-system 'undo-redo "Use the Emacs-native undo/redo functionality")
    (evil-want-C-i-jump t "'C-i' to jump to next location")
    (evil-want-C-u-scroll t "'C-u' to scroll by half a page")
    (evil-want-Y-yank-to-eol t "'Y' to yank to the end of the line")
    (evil-want-keybinding nil "Don't load bindings for additional modes (see 'Evil Collection'")
    :bind
    (:map evil-normal-state-map
          ("<up>" . 'evil-window-up)
          ("<down>" . 'evil-window-down)
          ("<left>" . 'evil-window-left)
          ("<right>" . 'evil-window-right)
          ("-" . dired-jump))
    :config
    (evil-mode 1))
#+end_src

Since =evil-want-C-u-scroll= is set to =t=, we need to rebind the /universal argument/ keybinding (which is =C-u= by default).

#+begin_src emacs-lisp
  (global-set-key (kbd "C-M-u") 'universal-argument)
#+end_src

** Evil Collection

There are parts of Emacs, e.g. =help-mode=, =M-x calendar=, Eshell, which are not covered by Evil. [[https://github.com/emacs-evil/evil-collection][Evil Collection]] is a community-sourced collection of Evil bindings that aims to provide a consistent Evil experience throughout Emacs.

#+begin_src emacs-lisp
  (use-package evil-collection
    :after evil
    :config
    (evil-collection-init))
#+end_src

** Evil Commentary

[[https://github.com/linktohack/evil-commentary][evil-commentary]] mimics the functionality of [[https://tpo.pe/][Tim Pope]]'s [[https://github.com/tpope/vim-commentary][commentary.vim]] plugin.

#+begin_src emacs-lisp
  (use-package evil-commentary
    :after evil
    :config
    (evil-commentary-mode))
#+end_src

* Keybindings

** macOS

#+begin_src emacs-lisp
  (if (eq system-type 'darwin)
      ;; Use command key as meta
      (setq mac-command-modifier 'meta)

    ;; Leave left option alone
    (setq mac-option-modifier 'none)

    ;; Map right option key to super
    (setq mac-right-option-modifier 'alt))
#+end_src

** General

https://github.com/noctuid/general.el

#+begin_src emacs-lisp
  ;; Make <escape> quit prompts
  (global-set-key (kbd "<escape>") 'keyboard-escape-quit)

  ;; General
  (use-package general
    :config
    (general-evil-setup)

    (general-create-definer ngs/leader-def
      :keymaps '(normal emacs)
      :prefix "SPC")

    (general-create-definer ngs/local-leader-def
      :keymaps '(normal emacs)
      :prefix ",")

    (ngs/leader-def
      "f"   '(:ignore t :which-key "find")
      "ff"  '(project-find-file :which-key "file")

      "p"  '(:ignore t :which-key "project")
      "pf" '(project-find-file :which-key "find file")
      "pk" '(project-kill-buffers :which-key "kill buffers")
      "pp" '(project-switch-project :which-key "switch")

      "g"  '(:ignore g :which-key "git")
      "gs" '(magit-status :which-key "status")

      "h"  '(:ignore g :which-key "help")
      "hh" '(helpful-at-point :which-key "at point")
      "hf" '(helpful-callable :which-key "function")
      "hc" '(helpful-command :which-key "command")
      "hk" '(helpful-key :which-key "key")
      "hK" '(describe-keymap :which-key "keymap")
      "hm" '(describe-mode :which-key "mode")
      "hv" '(helpful-variable :which-key "variable")

      "t"  '(:ignore t :which-key "toggles")
      "tt" '(treemacs :which-key "treemacs")))
#+end_src

** TODO: Winum

#+begin_src emacs-lisp
  (use-package winum
    :config
    (winum-mode)
    (ngs/leader-def
      "1" '(winum-select-window-1 :which-key "window-1")
      "2" '(winum-select-window-2 :which-key "window-2")
      "3" '(winum-select-window-3 :which-key "window-3")
      "4" '(winum-select-window-4 :which-key "window-4")
      "5" '(winum-select-window-5 :which-key "window-5")
      "6" '(winum-select-window-5 :which-key "window-6")
      "7" '(winum-select-window-5 :which-key "window-7")
      "8" '(winum-select-window-5 :which-key "window-8")
      "9" '(winum-select-window-5 :which-key "window-9")
      "0" '(winum-select-window-5 :which-key "window-10")))
#+end_src

* Editing

** Indentation

By default, indent with two spaces:

#+begin_src emacs-lisp
  (setq-default tab-width 2)
  (setq-default evil-shift-width tab-width)
  (setq-default indent-tabs-mode nil)
#+end_src

https://github.com/abo-abo/avy

#+begin_src emacs-lisp
  (use-package avy
    :after evil
    :bind (:map evil-normal-state-map
                ("s" . 'avy-goto-char-2)
                ("f"  . 'evil-avy-goto-char-in-line)))
#+end_src

https://github.com/rolandwalker/simpleclip

#+begin_src emacs-lisp
  (use-package simpleclip
     :bind
     (("M-c" . simpleclip-copy)
      ("M-v" . simpleclip-paste))
     :config
     (simpleclip-mode 1))
#+end_src

* Completion

In Emacs, a /completion system/ is a mechanism that surfaces a subset of items from some initial list based on user input. For instance, given a set of English words and an input of "comp", a completion system might return a list of words that begin with the letter sequence c-o-m-p, e.g. /complete/, /comprehensive/, /computer/.

The initial set of items, or /candidates/, is typically sourced based on the most recent action: ~find-file~ uses a set of files and directories, ~describe-function~ uses the set of known functions, etc.

I augment Emacs’ built-in completion systems with some excellent community packages.

** Vertico
  
[[https://github.com/minad/vertico][Vertico ]](VERTical Interactive COmpletion) enhances the built-in completion commands with an extensible vertical selection UI, sorting configurability affordances, support for annotations, and more. It’s a great upgrade out of the box and maintains full compatibility with the standard Emacs completion experience, thus reducing the likelihood of seeing unexpected behavior.

#+begin_src emacs-lisp
  (use-package vertico
    :init (vertico-mode))
#+end_src

** Marginalia

[[https://github.com/minad/marginalia][Marginalia]] adds rich annotations to completion candidates: 

- Descriptions of commands
- Filesystem details for files
- Value and description of variables

  #+begin_src emacs-lisp
    (use-package marginalia
      :init (marginalia-mode))
  #+end_src

** Consult

[[https://github.com/minad/consult][Consult]] adds a set of commands that provide interesting candidate sources and enhance existing ones. There are lots of great functions provided covering buffer-switching, grepping, Org navigation, and more.

#+begin_src emacs-lisp
  (use-package consult)

  (ngs/leader-def
    "SPC" '(consult-buffer :which-key "buffer")
    "/"   '(consult-line :which-key "line")
    "fg"  '(consult-grep :which-key "grep")
    "fl"  '(consult-line :which-key "line")
    "fr"  '(consult-recent-file :which-key "recent")
    "fb"  '(consult-buffer :which-key "buffer"))
#+end_src

** Orderless

[[https://github.com/oantolin/orderless][Orderless]] provides a completion style that allows a pattern to be divided into chunks that can be matched in any order. For instance, =buf cons= and =cons buf= will both match =consult-buffer=.

#+begin_src emacs-lisp
  (use-package orderless
    :init
    (setq completion-styles '(orderless)))
#+end_src

** Corfu

[[https://github.com/minad/corfu][Corfu]] (Completion Overlay Region FUnction) enhances completion at point, i.e. completion that occurs at the location of the cursor, with a pop-up completion UI. I load and enable =corfu-popupinfo=, an included extension that displays information for the selected completion candidate beside the candidate list.

#+begin_src elisp
    (defvar ngs/corfu-extensions-directory
      (format "%sstriaght/build/corfu/extensions" user-emacs-directory)
      "Path to Corfu’s included extensions")

    (use-package corfu
      :load-path ngs/corfu-extensions-directory
      :custom
      (corfu-auto t)
      :bind
      (:map corfu-map ("SPC" . corfu-insert-separator))
      :init
      (global-corfu-mode))
      ;; (require 'corfu-popupinfo)
      ;; (corfu-popupinfo-mode))
#+end_src

** Cape

[[https://github.com/minad/cape][Cape]]

TODO: Configure this

#+begin_src emacs-lisp
  (use-package cape)
#+end_src

* Programming

** Languages

I employ a number of programming language modes to provide syntax highlighting and other useful functions related to code I work with.

#+begin_src emacs-lisp
  (use-package elixir-ts-mode)
  (use-package json-mode)
  (use-package lua-mode)
  (use-package markdown-mode)
  (use-package nix-mode :mode "\\.nix\\'")
#+end_src

** Language Server Protocol

#+begin_src elisp
  (defvar ngs/language-server-programs
    '((elixir . '("~/Projects/elixir-ls/release/language_server.sh")))
    "Locations of LSP server binaries")

  (defun ngs/language-server-program (language)
    (cdr (assoc language ngs/language-server-programs)))
#+end_src

#+begin_src emacs-lisp
  (use-package eglot
    :config
    (add-to-list 'eglot-server-programs
     '(elixir-ts-mode  "~/Projects/elixir-ls/release/language_server.sh"))
    (add-to-list 'eglot-server-programs
     '(sql-mode  "sql-language-server" "up" "--method" "stdio"))
    :hook
    ((elixir-mode . eglot-ensure)
     (sql-mode . eglot-ensure)))
#+end_src

* Command-line Interface

TODO: https://github.com/akermu/emacs-libvterm
TODO: https://github.com/suonlight/multi-vterm

#+begin_src emacs-lisp
  (use-package vterm)
  (use-package multi-vterm)
#+end_src

* Org Mode

** Keybindings

#+begin_src emacs-lisp
  (use-package org
    :ensure nil
    :config
    (ngs/local-leader-def
      "l" '(org-insert-link :which-key "insert-link")))
#+end_src

** Emacs Configuration

TODO: Explore this function more (see https://github.com/daviwil/emacs-from-scratch/blob/master/show-notes/Emacs-07.org#tips)

#+begin_src emacs-lisp
  (defun ngs/org-babel-tangle-config ()
    (when (string-equal (buffer-file-name)
			(locate-user-emacs-file "config.org"))
      (let ((org-confirm-babel-evaluate nil))
	(org-babel-tangle))))

  (add-hook 'org-mode-hook (lambda ()
			     (add-hook 'after-save-hook #'ngs/org-babel-tangle-config)))
#+end_src

** Layout

#+begin_src emacs-lisp
  (defun ngs/org-mode-visual-fill ()
    (setq visual-fill-column-width 100
	  visual-fill-column-center-text t)
    (visual-line-mode 1)
    (visual-fill-column-mode 1))

  (use-package visual-fill-column
    :hook (org-mode . ngs/org-mode-visual-fill))
#+end_src

** Structure Templates

#+begin_src emacs-lisp
  (require 'org-tempo)

  (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
  (add-to-list 'org-structure-template-alist '("sh" . "src shell"))
#+end_src

** TODO org-imenu

#+begin_src emacs-lisp
  (use-package imenu-list)

  (use-package org-imenu
    :straight
    (org-imenu :host github
               :repo "rougier/org-imenu"))
#+end_src

* Version Control

The centerpiece of my version control setup is the excellent [[https://magit.vc/][Magit]] package.

#+begin_src emacs-lisp
  (use-package magit
    :config
    (ngs/leader-def
      "g" '(:ignore t :which-key "git")
      "gb" '(magit-blame :which-key "blame")
      "gl" '(magit-log :which-key "log")
      "gs" '(magit-status :which-key "git")))
#+end_src
