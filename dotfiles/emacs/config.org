#+TITLE: GNU Emacs Configuration
#+AUTHOR: N. G. Scheurich
#+EMAIL: nick@scheurich.haus
#+PROPERTY: header-args :tangle ./init-org.el

* Introduction

TODO: Rewrite to reflect new tangling setup.

This is my primary *GNU Emacs* configuration file. I say /primary/ because two other files, =early-init.el= and =init.el=, round out the whole of the configuration, though their purposes are tightly constrained and explained in more detail in each file.

This file is an [[https://orgmode.org/][Org Mode]] document written in a [[https://en.wikipedia.org/wiki/Literate_programming][literate programming]] style, with text meant for computer interpretation, i.e. /code/, intermingled with plain-language text meant to be parsed by humans. I find that this paradigm lends works nicely here, as it allows me to colocate my thoughts about parts of the setup along with the Emacs Lisp (Elisp) configuration code itself.

From a technical perspective, when Emacs is started each code block in this document is /tangled/ (exported using to a file using =org-babel-tangle=) and then loaded using =load-file=. Note that /loading/ a file in the context of Emacs typically refers to reading the file and then evaluating its contents as Elisp code, which is the case here.

** Inspiration & Reference

- [[https://github.com/daviwil/emacs-from-scratch][Emacs from Scratch]], a build-along configuration and video series by [[https://youtube.com/c/SystemCrafters][David Wilson]] of System Crafters
- Words, spoken and written, from [[https://protesilaos.com/emacs/][Protesilaos Stavrou]], aka /Prot/

* Package Management

** straight.el

Emacs has a built-in packager, =package.el=, but I prefer to use [[https://github.com/radian-software/straight.el][=straight.el=]] for a few key reasons:

- It affords the ability to use a specific Git revision of a package
- It only loads the packages specified in this configuration file
- It supports true portabilty/reproducibility via lockfiles
- It allows me to easily make ad-hoc changes to packages

There are further advantages, and some disadvantages, when compared to =package.el= which are enumerated in straight.elâ€™s [[https://github.com/raxod502/straight.el#comparison-to-packageel][README]].

#+begin_src emacs-lisp :tangle ./early-init-org.el
  ;; Prevent package.el from loading any packages
  (setq package-enable-at-startup nil)

  ;; Bootstrap straight.el, i.e. download and install and evaluate it if
  ;; it is not detected. See <https://github.com/raxod502/straight.el#getting-started>.
  (defvar bootstrap-version)
  (let ((bootstrap-file
         (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
        (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
    (url-retrieve-synchronously
     "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
     'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))
#+end_src

** use-package

The [[https://github.com/jwiegley/use-package][use-package]] macro is invaluable for keeping configuration code tidy and performant. The following installs it and ensures that packages in =use-package= forms are installed automatically using =straight.el=.

#+begin_src emacs-lisp
  (straight-use-package 'use-package)
  (setq straight-use-package-by-default t)
#+end_src

* Defaults

** Settings

There are a series of built-in customizable variables that I change to better suit my personal tastes and workflows.

#+begin_src emacs-lisp
  (use-package emacs
    :ensure nil
    :custom
    (confirm-kill-emacs #'yes-or-no-p "Confirm before quitting")
    (custom-file (locate-user-emacs-file "custom-vars.el") "Set custom file path")
    (frame-resize-pixelwise t "Resize frames by pixels rather than characters")
    (gc-cons-threshold (* 2 1000 1000) "Make GC pauses faster by decreasing threshold")
    (history-length 40 "Maximum number of files to keep in history")
    (inhibit-startup-message t "Bypass the Emacs splash screen")
    (message-kill-buffer-query nil "Don't ask to confirm buffer kill")
    (ring-bell-function 'ignore "Suppress the bell")
    (use-short-answers t "Abbreviate yes/no input")
    (user-email-address "nick@scheurich.haus" "My email address")
    (user-full-name "Nicholas Scheurich" "My full name")
    (window-resize-pixelwise t "Resize windows by pixels rather than characters"))
#+end_src

** Modes

=global-auto-revert-mode= automatically update the contents of certain buffers when their respective files change on disk.

#+begin_src emacs-lisp
  (global-auto-revert-mode 1)
#+end_src

=save-place-mode= saves the last position in file buffers.

#+begin_src emacs-lisp
  (save-place-mode t)
#+end_src

=recentf-mode= remembers recently-visited files, which can be selected from using the =recentf= interactive function.

#+begin_src emacs-lisp
  (recentf-mode t)
#+end_src

** Packages

The =savehist= package remembers prompt inputs between sessions, thereby creating a persistent command history.

#+begin_src emacs-lisp
  (use-package savehist
    :ensure nil
    :init
    (setq history-length 40)
    (savehist-mode))
#+end_src

* User Interface

The Emacs user interface is endlessly customizable. For starters, I disable some unwanted UI elements, namely the tool bar and scroll bar.

#+begin_src emacs-lisp
  (tool-bar-mode -1)
  (scroll-bar-mode -1)
#+end_src

** Typography

My preferred monospaced programming font these days is [[https://www.monolisa.dev/][MonoLisa]] by [[https://www.facetype.org/][Marcus Sterz]]. I set this font as the default and slightly increase the leading.

#+begin_src emacs-lisp
  (set-face-attribute 'default nil :font "MonoLisa" :height 110)
  (setq-default line-spacing 0.2)
#+end_src

** Themes

I use the [[https://protesilaos.com/emacs/modus-themes][Modus themes]] by Protesilaos Stavrou, which are optimized for color-contrast accessibility. The basic Modus themes are distributed with Emacs as of version 28.1. However, I prefer the /-tinted/ variants and so load the package from ELPA.

#+begin_src emacs-lisp
  (use-package modus-themes)
#+end_src

[[https://github.com/GuidoSchmidt/circadian.el][Circadian]] package loads the dark-on-light Modus theme (=modus-operandi-tinted=) or the light-on-dark one (=modus-vivendi-tinted=) based on the time of day.

#+begin_src emacs-lisp
  (use-package circadian
    :config
    (setq circadian-themes '(("07:30" . modus-operandi-tinted)
                             ("19:30" . modus-vivendi-tinted)))
    (circadian-setup))
#+end_src

** Line Numbers

Quickly referencing line number is a huge convenience when viewing and editing source code, so I enable =display-line-numbers-mode= for programming mode buffers.

#+begin_src emacs-lisp
(add-hook 'prog-mode-hook #'display-line-numbers-mode)
#+end_src

** Mode Line

#+begin_src emacs-lisp
  (setq column-number-mode t)
#+end_src

** ElDoc

TODO Describe ElDoc

#+begin_src emacs-lisp
  (use-package eldoc
    :ensure nil
    :init
    (setq eldoc-echo-area-use-multiline-p nil))
#+end_src

* Evil

Having near-perfect Vim emulation is a prime requirement for any platform with which I will be doing heavy text editing. Luckily [[https://github.com/emacs-evil/evil][Evil]], the *extensible vi layer* for Emacs is superb.

TODO List Vim packages that Evil emulates.

#+begin_src  emacs-lisp
  (use-package evil
    :custom
    (evil-echo-state nil "Don't display the Evil state in the echo area")
    (evil-undo-system 'undo-redo "Use the Emacs-native undo/redo functionality")
    (evil-want-C-i-jump t "'C-i' to jump to next location")
    (evil-want-C-u-scroll t "'C-u' to scroll by half a page")
    (evil-want-Y-yank-to-eol t "'Y' to yank to the end of the line")
    (evil-want-keybinding nil "Don't load bindings for additional modes (see 'Evil Collection'")
    :config
    (evil-mode 1))
#+end_src

Since =evil-want-C-u-scroll= is set to =t=, we need to rebind the /universal argument/ keybinding (which is =C-u= by default).

#+begin_src emacs-lisp
  (global-set-key (kbd "C-M-u") 'universal-argument)
#+end_src

** Evil Collection

There are parts of Emacs, e.g. =help-mode=, =M-x calendar=, Eshell, which are not covered by Evil. [[https://github.com/emacs-evil/evil-collection][Evil Collection]] is a community-sourced collection of Evil bindings that aims to provide a consistent Evil experience throughout Emacs.

#+begin_src emacs-lisp
  (use-package evil-collection
    :after evil
    :config
    (evil-collection-init))
#+end_src

** Evil Commentary

[[https://github.com/linktohack/evil-commentary][evil-commentary]] mimics the functionality of [[https://tpo.pe/][Tim Pope]]'s [[https://github.com/tpope/vim-commentary][commentary.vim]] plugin.

#+begin_src emacs-lisp
  (use-package evil-commentary
    :after evil
    :config
    (evil-commentary-mode))
#+end_src

* Keybindings

** macOS

#+begin_src emacs-lisp
  (if (eq system-type 'darwin)
      ;; Use command key as meta
      (setq mac-command-modifier 'meta)

    ;; Leave left option alone
    (setq mac-option-modifier 'none)

    ;; Map right option key to super
    (setq mac-right-option-modifier 'alt))
#+end_src

** General

https://github.com/noctuid/general.el

#+begin_src emacs-lisp
  ;; Make <escape> quit prompts
  (global-set-key (kbd "<escape>") 'keyboard-escape-quit)

  ;; General
  (use-package general
    :config
    (general-evil-setup)

    (general-create-definer ngs/leader-def
      :keymaps '(normal emacs)
      :prefix "SPC")

    (general-create-definer ngs/local-leader-def
      :keymaps '(normal emacs)
      :prefix ",")

    (ngs/leader-def
      "f"   '(:ignore t :which-key "find")
      "ff"  '(project-find-file :which-key "file")

      "p"  '(:ignore t :which-key "project")
      "pf" '(project-find-file :which-key "find file")
      "pk" '(project-kill-buffers :which-key "kill buffers")
      "pp" '(project-switch-project :which-key "switch")

      "g"  '(:ignore g :which-key "git")
      "gs" '(magit-status :which-key "status")

      "h"  '(:ignore g :which-key "help")
      "hh" '(helpful-at-point :which-key "at point")
      "hf" '(helpful-callable :which-key "function")
      "hc" '(helpful-command :which-key "command")
      "hk" '(helpful-key :which-key "key")
      "hK" '(describe-keymap :which-key "keymap")
      "hm" '(describe-mode :which-key "mode")
      "hv" '(helpful-variable :which-key "variable")

      "t"  '(:ignore t :which-key "toggles")
      "tt" '(treemacs :which-key "treemacs")))
#+end_src

* Editing

** Indentation

By default, indent with two spaces:

#+begin_src emacs-lisp
  (setq-default tab-width 2)
  (setq-default evil-shift-width tab-width)
  (setq-default indent-tabs-mode nil)
#+end_src

https://github.com/abo-abo/avy

#+begin_src emacs-lisp
  (use-package avy
    :after evil
    :bind (:map evil-normal-state-map
                ("s" . 'avy-goto-char-2)
                ("f"  . 'evil-avy-goto-char-in-line)))
#+end_src

https://github.com/rolandwalker/simpleclip

#+begin_src emacs-lisp
  (use-package simpleclip
     :bind
     (("M-c" . simpleclip-copy)
      ("M-v" . simpleclip-paste))
     :config
     (simpleclip-mode 1))
#+end_src

* Completion

In Emacs, a /completion system/ is a mechanism that surfaces a subset of items from some initial list based on user input. For instance, given a set of English words and an input of "comp", a completion system might return a list of words that begin with the letter sequence c-o-m-p, e.g. /complete/, /comprehensive/, /computer/.

The initial set of items, or /candidates/, is typically sourced based on the most recent action: `=find-file=` uses a set of files and directories, `=describe-function` uses the set of known functions, etc.

I augment Emacsâ€™ built-in completion systems with some excellent community packages:

- [[https://github.com/minad/vertico][Vertico]]
- [[https://github.com/minad/marginalia][Marginalia]]
- [[https://github.com/minad/consult][Consult]]
- [[https://github.com/oantolin/orderless][Orderless]]
- [[https://github.com/minad/corfu][Corfu]]
- [[https://github.com/minad/cape][Cape]]

** Vertico
  
*Vertico* (VERTical Interactive COmpletion) enhances the built-in completion commands with an extensible vertical selection UI, sorting configurability affordances, support for annotations, and more. Itâ€™s a great upgrade out of the box and maintains full compatibility with the standard Emacs completion experience, thus reducing the likelihood of seeing unexpected behavior.

#+begin_src emacs-lisp
  (use-package vertico
    :init (vertico-mode))
#+end_src

** Marginalia

*Marginalia* adds rich annotations to completion candidates: 

- Descriptions of commands
- Filesystem details for files
- Value and description of variables

  #+begin_src emacs-lisp
    (use-package marginalia
      :init (marginalia-mode))
  #+end_src

** Consult

*Consult* adds a set of commands that provide interesting candidate sources and enhance existing ones. There are lots of great functions provided covering buffer-switching, grepping, Org navigation, and more.

#+begin_src emacs-lisp
  (use-package consult)

  (ngs/leader-def
    "SPC" '(consult-buffer :which-key "buffer")
    "/"   '(consult-line :which-key "line")
    "fg"  '(consult-grep :which-key "grep")
    "fl"  '(consult-line :which-key "line")
    "fr"  '(consult-recent-file :which-key "recent")
    "fb"  '(consult-buffer :which-key "buffer"))
#+end_src

** Orderless

*Orderless* provides a completion style that allows a pattern to be divided into chunks that can be matched in any order. For instance, =buf cons= and =cons buf= will both match =consult-buffer=.

#+begin_src emacs-lisp
  (use-package orderless
    :init
    (setq completion-styles '(orderless)))
#+end_src

** Corfu

*Corfu* (Completion Overlay Region FUnction) enhances completion at point, i.e. completion that occurs at the location of the cursor, with a pop-up completion UI. I load and enable =corfu-popupinfo=, an included extension that displays information for the selected completion candidate beside the candidate list.

#+begin_src elisp
    (defvar ngs/corfu-extensions-directory
      (format "%sstriaght/build/corfu/extensions" user-emacs-directory)
      "Path to Corfuâ€™s included extensions")

    (use-package corfu
      :load-path ngs/corfu-extensions-directory
      :custom
      (corfu-auto t)
      :bind
      (:map corfu-map ("SPC" . corfu-insert-separator))
      :init
      (global-corfu-mode))
      ;; (require 'corfu-popupinfo)
      ;; (corfu-popupinfo-mode))
#+end_src

** Cape

https://github.com/minad/cape

TODO Configure this

#+begin_src emacs-lisp
  (use-package cape)
#+end_src

* Programming

** Languages

I employ a number of programming language modes to provide syntax highlighting and other useful functions related to code I work with.

#+begin_src emacs-lisp
  (use-package elixir-ts-mode)
  (use-package json-mode)
  (use-package lua-mode)
  (use-package markdown-mode)
  (use-package nix-mode :mode "\\.nix\\'")
#+end_src

** Language Server Protocol

#+begin_src elisp
  (defvar ngs/language-server-programs
    '((elixir . '("~/Projects/elixir-ls/release/language_server.sh")))
    "Locations of LSP server binaries")

  (defun ngs/language-server-program (language)
    (cdr (assoc language ngs/language-server-programs)))
#+end_src

#+begin_src emacs-lisp
  (use-package eglot
    :config
    (add-to-list 'eglot-server-programs
		 '(elixir-ts-mode  "~/Projects/elixir-ls/release/language_server.sh"))
    :hook
    ((elixir-mode . eglot-ensure)))
#+end_src

* Shells

https://github.com/akermu/emacs-libvterm
https://github.com/suonlight/multi-vterm

#+begin_src emacs-lisp
  (use-package vterm)
  (use-package multi-vterm)
#+end_src

* Org Mode

** Emacs Configuration

TODO Explore this function more (see https://github.com/daviwil/emacs-from-scratch/blob/master/show-notes/Emacs-07.org#tips)

#+begin_src emacs-lisp
  (defun ngs/org-babel-tangle-config ()
    (when (string-equal (buffer-file-name)
                        (locate-user-emacs-file "config.org"))
      (let ((org-confirm-babel-evaluate nil))
        (org-babel-tangle))))

  (add-hook 'org-mode-hook (lambda ()
                             (add-hook 'after-save-hook #'ngs/org-babel-tangle-config)))
#+end_src

** Layout

#+begin_src emacs-lisp
  (defun ngs/org-mode-visual-fill ()
    (setq visual-fill-column-width 100
	  visual-fill-column-center-text t)
    (visual-line-mode 1)
    (visual-fill-column-mode 1))

  (use-package visual-fill-column
    :hook (org-mode . ngs/org-mode-visual-fill))
#+end_src

** Structure Templates

#+begin_src emacs-lisp
  (require 'org-tempo)

  (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
  (add-to-list 'org-structure-template-alist '("sh" . "src shell"))
#+end_src
